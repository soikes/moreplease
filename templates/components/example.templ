package components

import (
	"encoding/json"
	"soikke.li/moreplease/pkg/db"
	"soikke.li/moreplease/pkg/model"
)

type Example struct {
	Language   model.Language
	Statements db.Statements
}

templ (e *Example) Run(path string) {
	<div class="example sticky-container fade-in">
		<div class="tile sticky">
			{{
				s := struct {
					Schema      string `json:"schema"`
					InitialStmt string `json:"initial_stmt"`
					Stmt        string `json:"stmt"`
					Result      string `json:"result"`
				}{
					Schema:      e.Statements.From(e.Statements.SchemaPath),
					InitialStmt: e.Statements.From(path),
					Stmt:        e.Statements.From(path),
					Result:      "",
				}
				state, err := json.Marshal(s)
				if err != nil {
					panic(err)
				}
			}}
			<sql-example data-state={ string(state) }>
				<div class="stmt">
					<textarea
						spellcheck="false"
						autocorrect="off"
						autocapitalize="off"
						data-bind="stmt"
					></textarea>
					<pre>
						<code class={ e.Language.CSSClass() }></code>
					</pre>
				</div>
				<button id="run" class="run"><img src="assets/run.svg"/> run</button>
				<button id="reset" class="run"><img src="assets/reset.svg"/> reset</button>
				<div data-bind="result" id="result" class="result"></div>
			</sql-example>
			// TODO: include this pre-rendered block conditionally before the client side runs
			/* <div x-show="!result">
                <pre>
                    { e.Statements.ExecFile(path) }
                </pre>
            </div>
            <div x-show="result">
                <pre x-text="result"></pre>
            </div> */
		</div>
	</div>
}

templ (e *Example) Display(path string) {
	<div class="sticky-container">
		<div class="tile sticky">
			{{
				stmt := e.Statements.From(path)
			}}
			<pre>
				<code class={ e.Language.CSSClass() } x-text="stmt" x-ref="codeBlock">{ stmt }</code>
			</pre>
		</div>
	</div>
}
