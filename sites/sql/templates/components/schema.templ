package components

import (
	"bytes"
	"context"
	"fmt"
	"soikke.li/moreplease/pkg/db"
	"soikke.li/moreplease/pkg/model"
	"soikke.li/moreplease/sites/sql/assets"
	"soikke.li/moreplease/sites/sql/site"
	c "soikke.li/moreplease/templates/components"
)

type Schema struct {
	Page   model.Page
	Config db.Config
}

templ (s *Schema) Component(tables ...string) {
	{{
		var docBuf bytes.Buffer
		err := s.PopoutComponent(tables...).Render(context.Background(), &docBuf)
		if err != nil {
			panic(err)
		}
		var htmlBuf bytes.Buffer
		err = templ.Raw(docBuf.String()).Render(context.Background(), &htmlBuf)
		if err != nil {
			panic(err)
		}
	}}
	if len(tables) > 0 {
		<details id="schema" class="toggle">
			<summary
				class="action heading"
				data-open="hide tables"
				data-close="show tables"
			></summary>
			<popout-doc data-document={ htmlBuf.String() } class="heading popout">
				<span>
					@c.Outlink("#", "pop out tables")
				</span>
			</popout-doc>
			@innerSchema(s.Config, tables...)
		</details>
	}
}

templ (s *Schema) PopoutComponent(tables ...string) {
	{{
		title := fmt.Sprintf("%s (Tables)", s.Page.Title)
		b := c.Base{
			Title: title,
		}
	}}
	@b.Component(HashedImports(assets.Assets)) {
		@c.TopicTitle(site.MSP.Title, title)
		@innerSchema(s.Config, tables...)
	}
}

templ innerSchema(cfg db.Config, tables ...string) {
	<div id="schema">
		<div class="container">
			for _, table := range tables {
				<div class="tile">
					<div class="tablename">
						{ table }
					</div>
					<div class="table result">
						{ cfg.MustQueryFile(fmt.Sprintf("schema/dump_%s.sql", table)) }
					</div>
				</div>
			}
		</div>
	</div>
}
