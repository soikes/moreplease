package topics

import (
	"soikke.li/moreplease/pkg/db"
	"soikke.li/moreplease/pkg/render"
	"soikke.li/moreplease/sites/sql/site"
	sqlc "soikke.li/moreplease/sites/sql/templates/components"
	"soikke.li/moreplease/sites/sql/topics/statements"
	c "soikke.li/moreplease/templates/components"
)

func init() {
	render.MustRegisterComponent(site.UpdatePage.Asset(), Update())
}

templ Update() {
	{{
		cfg := db.Config{
			SQLFiles:   statements.MustSub("update"),
			SchemaPath: "schema/schema.sql",
		}
		e := c.Example{
			Config: cfg,
		}
		p := site.MSP.Page(site.UpdatePage)
		schema := sqlc.Schema{Page: p, Config: cfg}
	}}
	@sqlc.Page{Page: p}.Component() {
		@schema.Component("users")
		<div class="content__two-column">
			<div>
				<p>
					The 
					<span>
						@c.InlineSQL("UPDATE")
					</span> statement allows you to update existing rows with new values for one or more columns.
				</p>
				<p>
					An 
					<span>
						@c.InlineSQL("UPDATE")
					</span> will modify every row of the table unless a 
					<span>
						@c.InlineSQL("WHERE")
					</span> clause is provided. 
				</p>
				<p>
					It is not required to provide a 
					<span>
						@c.InlineSQL("WHERE")
					</span> clause but it is highly recommended to avoid accidental updates to the entire table. Some database engines will warn or even prevent you from running a table-wide 
					<span>
						@c.InlineSQL("UPDATE")
					</span> statement.
				</p>
				<p>
					You can run a 
					<span>
						@c.InlineSQL("SELECT")
					</span> statement with the same 
					<span>
						@c.InlineSQL("WHERE")
					</span> clause to check which rows will be altered with an 
					<span>
						@c.InlineSQL("UPDATE")
					</span> before actually performing the update.
				</p>
				<p>
					Remember that each example on this website is editable and runnable so you can see the results of your 
					<span>
						@c.InlineSQL("UPDATE")
					</span> by querying the contents of the table, i.e.: 
					<span>
						@c.InlineSQL("SELECT * FROM users;")
					</span>
				</p>
			</div>
			@e.Run("update.sql")
			<div>
				<p>
					You can update multiple columns within the same 
					<span>
						@c.InlineSQL("UPDATE")
					</span> statement.
				</p>
			</div>
			@e.Run("update_multiple.sql")
			<div>
				An 
				<span>
					@c.InlineSQL("UPDATE")
				</span> can use the result of a computation. This example shows using negation logic to toggle the value of a column between 
				<span>
					@c.InlineSQL("0")
				</span> and 
				<span>
					@c.InlineSQL("1")
				</span> on each update.
			</div>
			@e.Run("update_computation.sql")
			<div>
				<p>
					Similar to an 
					<span>
						@c.InlineSQL("INSERT")
					</span>,
					<span>
						@c.InlineSQL("UPDATE")
					</span> accepts an optional fallback strategy using 
					<span>
						@c.InlineSQL("OR")
					</span> when the update would cause a constraint violation and fail.
				</p>
				<p>
					Try removing the 
					<span>
						@c.InlineSQL("OR IGNORE")
					</span> clause and run the example again. Notice that the 
					<span>
						@c.InlineSQL("UPDATE")
					</span> now fails with an error.
				</p>
			</div>
			@e.Run("update_or.sql")
			<div>
				Some database engines support the 
				<span>
					@c.InlineSQL("RETURNING")
				</span> clause, which will cause the database to return the rows that were updated. You can specify column names to return or 
				<span>
					@c.InlineSQL("*")
				</span> to include all columns.
			</div>
			@e.Run("update_returning.sql")
		</div>
	}
}
