package topics

import (
	"soikke.li/moreplease/pkg/db"
	"soikke.li/moreplease/pkg/model"
	"soikke.li/moreplease/sites/sql/render"
	"soikke.li/moreplease/sites/sql/site"
	sqlc "soikke.li/moreplease/sites/sql/templates/components"
	"soikke.li/moreplease/sites/sql/topics/statements"
	c "soikke.li/moreplease/templates/components"
)

func init() {
	render.Registry.MustRegisterComponent(site.AggregateFunctionsPage.Asset(), AggregateFunctions())
}

templ AggregateFunctions() {
	{{
	cfg := db.Config{
		SQLFiles:   statements.MustSub("aggregate_functions"),
		SchemaPath: "schema/schema.sql",
	}
	e := c.Example{
		Language: model.LanguageSQL,
		Config:   cfg,
	}
	p := site.MSP.Page(site.AggregateFunctionsPage)
	schema := sqlc.Schema{Page: p, Config: cfg}
	}}
	@sqlc.Page{Page: p}.Component() {
		@schema.Component("users", "donations")
		<article class="content__two-column">
			<div>
				<p>
					The 
					<span>
						@c.Link(site.MSP.Page(site.FunctionsPage), "")
					</span> topic introduces the concept of simple/scalar functions, which accept zero or more input values and produce a single output value per row.				
				</p>
				<p>
					<i>Aggregate functions</i> are categorized differently because they operate on more than one row of data at a time.
				</p>
				<p>
					<span>
						@c.InlineSQL("count()")
					</span> is a function that accepts a column name or a 
					<span>
						@c.InlineSQL("*")
					</span> as input. Instead of returning data though, it returns a count of the total number of rows.  If a 
					<span>
						@c.InlineSQL("*")
					</span> is specified, the count of all rows in the table is returned. Think of it as asking for a row count "including all columns".
				</p>
			</div>
			@e.Run("count.sql")
			<div>
				<p>
					If a column name is specified, the returned count is the number of non-
					<span>
						@c.InlineSQL("NULL")
					</span> rows.
				</p>
			</div>
			@e.Run("count_column.sql")
			<div>
				<p>
					Aggregate functions can accept a 
					<span>
						@c.InlineSQL("DISTINCT")
					</span> clause which causes duplicate rows to be ignored by the function. Here, the second "Amini" last name is not included in the count.
				</p>
			</div>
			@e.Run("count_distinct.sql")
			<div>
				<p>
					Another commonly used aggregate function is 
					<span>
						@c.InlineSQL("max()")
					</span><span>.</span> It accepts a single column name and returns the maximum value out of all of the rows. The maximum value is determined in the same way as an 
					@c.LinkWithText(site.MSP.Page(site.OrderByPage), "") {
						@c.InlineSQL("ORDER BY")
					}
					: by following the current 
					<span>
						@c.LinkWithText(site.MSP.Page(site.OrderByPage), "collation") {
							collation
						}
					</span> <span>for</span> that data type.
				</p>
				<p>
					To instead find the minimum value, the 
					<span>
						@c.InlineSQL("min()")
					</span> function is used.
				</p>
				<p>
					Keep in mind that in SQLite and other databases, 
					<span>
						@c.InlineSQL("max()")
					</span> and 
					<span>
						@c.InlineSQL("min()")
					</span> have versions that accept multiple arguments which are actually scalar functions that perform a different task.
				</p>
			</div>
			@e.Run("max.sql")
			<div>
				<p>
					The 
					<span>
						@c.InlineSQL("sum()")
					</span> function calculates the sum of all non-
					<span>
						@c.InlineSQL("NULL")
					</span> values. 
				</p>
				<p>
					If every input row is 
					<span>
						@c.InlineSQL("NULL")
					</span> then 
					<span>
						@c.InlineSQL("sum()")
					</span> will return 
					<span>
						@c.InlineSQL("NULL")
					</span><span>.</span> Unfortunately this is required by the SQL standard and several aggregate functions behave this way. This is not very useful if you are expecting a numerical result so some databases like SQLite have implemented a nonstandard 
					<span>
						@c.InlineSQL("total()")
					</span> function that returns 0.0 in this case instead.
				</p>
			</div>
			@e.Run("sum.sql")
			<div>
				<p>
					The 
					<span>
						@c.InlineSQL("avg()")
					</span> function calculates an average value across all the rows. It is equivalent to running 
					<span>
						@c.InlineSQL("total() / count()")
					</span><span>.</span> Note again that only non-
					<span>
						@c.InlineSQL("NULL")
					</span> values are considered in the calculation.
				</p>
				<p>
					In SQLite string values that can't be converted into numbers, such as 
					<span>
						@c.InlineSQL("'hello'")
					</span>, are treated as 
					<span>
						@c.InlineSQL("0")
					</span> in the average calculation.
				</p>
			</div>
			@e.Run("avg.sql")
			<div>
				<p>
					There are often more built-in aggregate functions to use as well as the ability to define your own aggregate functions similar to scalar functions.
				</p>
				<p>
					Aggregate functions are powerful tools alone but they become even more useful when combined with the 
					<span>
						@c.LinkWithText(site.MSP.Page(site.GroupByPage), "") {
							<span>
								@c.InlineSQL("GROUP BY")
							</span>
						}
					</span> clause which we will explore next.
				</p>
			</div>
		</article>
	}
}
