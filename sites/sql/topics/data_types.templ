package topics

import (
	"soikke.li/moreplease/pkg/db"
	"soikke.li/moreplease/pkg/render"
	"soikke.li/moreplease/sites/sql/site"
	c "soikke.li/moreplease/templates/components"
	l "soikke.li/moreplease/templates/layouts"
)

func init() {
	render.MustRegisterComponent(site.DataTypesPage.Asset(), DataTypes())
}

templ DataTypes() {
	{{
	s := db.Statements{
		Files:      mustSub("embed/data_types"),
		SchemaPath: "schema/schema.sql",
	}
	e := c.Example{
		Statements: s,
	}
	}}
	@l.Page{Site: site.MSP, Page: site.MSP.Page(site.DataTypesPage)}.Render() {
		@c.Schema(s, "profiles")
		<div class="container">
			<div>
				<p>
					Relational databases typically require you to define which type of data you would like to store in each column. This is done at the time of table creation.
				</p>
				<p>
					The SQL Standard defines over 20 different data types for things like numbers, text, dates and more. The various database vendors such as PostgreSQL, MySQL, Microsoft SQL Server, and Oracle Database may not support them all and they may define their own extra types.
				</p>
				<p>
					This example uses a built-in SQLite function called 
					<span>
						@c.Inline("pragma_table_info()")
					</span> on our 
					<span>
						@c.Inline("profiles")
					</span> table to show each column and its data type.
				</p>
				<p>
					SQLite is different in that instead of exposing all of these different types, it simplifies things for the user by using just five basic types:
				</p>
				<p>
					<span>
						@c.Inline("INTEGER")
					</span> for whole numbers.
				</p>
				<p>
					<span>
						@c.Inline("REAL")
					</span> for floating-point (decimal) numbers.
				</p>
				<p>
					<span>
						@c.Inline("TEXT")
					</span> for text-based data.
				</p>
				<p>
					<span>
						@c.Inline("BLOB")
					</span> for binary data.
				</p>
				<p>
					<span>
						@c.Inline("NULL")
					</span> for representing the absence of any type of data. Typically you can define columns to allow or disallow 
					<span>
						@c.Inline("NULL")
					</span>s using 
					<span>
						@c.Link(site.MSP.Page(site.ConstraintsPage), "")
					</span>.
				</p>
				<p>
					<span>
						@c.Inline("ANY")
					</span> is a special keyword for a column that can accept any type of data. SQLite is unique in that it also allows dynamically-typed columns. See <a href="https://www.sqlite.org/datatype3.html">Datatypes in SQLite</a> for more details on data types.
				</p>
				<p>
					Each type has a maximum storage size in bytes which will limit how much data or how big of a value you can store in each row. Depending on your vocation and reasons for learning SQL you may or may not need to know those details, for example the maximum byte size of a data type.
				</p>
				<p>
					Don't worry if you don't understand what a byte is â€” that information is included as a starting point for those who want to learn more.
				</p>
				<p>
					Below you will see a more complete list of types from the SQL Standard and/or available to use in other database engines.
				</p>
			</div>
			@e.Run("data_types.sql")
			<div>
				<p>
					<i><b>Numeric types:</b></i>
					<p>
						<span>
							@c.Inline("TINYINT")
						</span>, 
						<span>
							@c.Inline("SMALLINT")
						</span> and 
						<span>
							@c.Inline("MEDIUMINT")
						</span> for smaller positive/negative whole numbers; takes less space.
					</p>
					<p>
						<span>
							@c.Inline("INT")
						</span> or 
						<span>
							@c.Inline("INTEGER")
						</span> for positive/negative whole numbers.
					</p>
					<p>
						<span>
							@c.Inline("BIGINT")
						</span> for larger whole numbers; takes more space.
					</p>
				</p>
			</div>
			@e.Run("integer.sql")
			<div>
				<p>
					<span>
						@c.Inline("FLOAT")
					</span>, 
					<span>
						@c.Inline("DOUBLE PRECISION")
					</span> and 
					<span>
						@c.Inline("REAL")
					</span> for floating point (decimal) numbers. Typically a 
					<span>
						@c.Inline("FLOAT")
					</span> can store 4 bytes (around 6 digits) of data, a 
					<span>
						@c.Inline("DOUBLE PRECISION")
					</span> can store 8 bytes (around 15 digits), and 
					<span>
						@c.Inline("REAL")
					</span> is usually equivalent to a 
					<span>
						@c.Inline("FLOAT")
					</span>. Sometimes database vendors use 
					<span>
						@c.Inline("FLOAT(n)")
					</span> where 
					<span>
						@c.Inline("n")
					</span> is the storage space in bytes to use.
				</p>
				<p>
					<span>
						@c.Inline("DECIMAL(p,s)")
					</span> or 
					<span>
						@c.Inline("NUMERIC(p,s)")
					</span> for exact-precision floating point numbers. The 
					<span>
						@c.Inline("p")
					</span> stands for "precision" and specifies the maximum amount of total digits. The 
					<span>
						@c.Inline("s")
					</span> stands for "scale" and specifies the maximum amount of digits to the right of the decimal point. Both types exist for historical reasons but most modern databases treat 
					<span>
						@c.Inline("DECIMAL")
					</span> and 
					<span>
						@c.Inline("NUMERIC")
					</span> as synonyms. See your database's documentation to be sure.
				</p>
			</div>
			@e.Run("real.sql")
			<div>
				<p>
					<i><b>Text/string types:</b></i>
					<p>
						<span>
							@c.Inline("CHAR(n)")
						</span> for fixed-length strings. 
						<span>
							@c.Inline("n")
						</span> specifies how many characters the strings will have. Every row will store the same size of string regardless of how large the inserted strings are and the string will be padded or truncated.
					</p>
					<p>
						<span>
							@c.Inline("VARCHAR(n)")
						</span> for variable-length strings. 
						<span>
							@c.Inline("n")
						</span> specifies the maximum amount of characters a string can have.
					</p>
					<p>
						<span>
							@c.Inline("TEXT")
						</span> for variable-length strings without a specified maximum. Typically this type has a very large maximum size and varies by database.
					</p>
				</p>
			</div>
			@e.Run("text.sql")
			<div>
				<p>
					<i><b>Date/Time types:</b></i>
					<p>
						<span>
							@c.Inline("DATE")
						</span> for dates including the year, month and day.
					</p>
					<p>
						<span>
							@c.Inline("TIME")
						</span> for times of day including the hour, minute and second.
					</p>
					<p>
						<span>
							@c.Inline("TIMESTAMP")
						</span> or 
						<span>
							@c.Inline("DATETIME")
						</span> for a combination of both date and time.
					</p>
					<p>
						SQLite does not include any special type for storing dates or times; it uses 
						<span>
							@c.Inline("TEXT")
						</span> for this purpose and includes several built-in <a href="/functions">functions</a> for working with dates and times.
					</p>
				</p>
			</div>
			@e.Run("date.sql")
			<div>
				<p>
					<i><b>Binary types:</b></i>
					<p>
						<span>
							@c.Inline("BINARY(n)")
						</span> for fixed length 
						<span>
							@c.Outlink("https://en.wikipedia.org/wiki/Binary_file", "binary data")
						</span>, for example image data. 
						<span>
							@c.Inline("n")
						</span> specifies the amount of bytes all rows will have. Every row will store the same size of data regardless of how large the inserted data is and the data will be padded or truncated.
					</p>
					<p>
						<span>
							@c.Inline("VARBINARY(n)")
						</span> for variable length binary data. 
						<span>
							@c.Inline("n")
						</span> specifies the maximum amount of bytes rows can have.
					</p>
					<p>
						<span>
							@c.Inline("BLOB")
						</span> for variable-length binary objects without a specified maximum. Typically this type has a very large maximum size and varies by database. "BLOB" stands for "Binary Large Object".
					</p>
					<p>
						This example shows a text representation of what binary data would look like if stored in a SQLite 
						<span>
							@c.Inline("BLOB")
						</span> column. In reality, binary data in its native format cannot be rendered as text and would look garbled or display squares. The 
						<span>
							@c.Inline("x'...'")
						</span> format shown here can actually be used to insert the hexadecimal string representation of binary data into the column.
					</p>
				</p>
			</div>
			@e.Run("binary.sql")
			<div>
				<p>
					<i><b>Boolean types:</b></i>
					<p>
						<span>
							@c.Inline("BOOLEAN")
						</span> for true/false values. This means every row must either be 
						<span>
							@c.Inline("TRUE")
						</span> or 
						<span>
							@c.Inline("FALSE")
						</span>.
					</p>
					<p>
						SQLite has no built-in 
						<span>
							@c.Inline("BOOLEAN")
						</span> type; boolean values are stored as the integer 
						<span>
							@c.Inline("0")
						</span> for false and 
						<span>
							@c.Inline("1")
						</span> for true.
					</p>
				</p>
			</div>
			@e.Run("boolean.sql")
			<div>
				<p>
					<i><b>Other types:</b></i>
					<p>
						<span>
							@c.Inline("JSON")
						</span> for JSON-formatted data. Many modern databases have features and functions to deal specifically with JSON data.
					</p>
					<p>
						<span>
							@c.Inline("XML")
						</span> for XML-formatted data. Several modern databases have features specifically for working with XML data.
					</p>
					<p>
						<span>
							@c.Inline("UUID")
						</span> for UUID-formatted IDs. Some databases have this as a built-in type so the data can be stored, found and compared more efficiently than a 
						<span>
							@c.Inline("TEXT")
						</span>-like type.
					</p>
				</p>
			</div>
		</div>
	}
}
