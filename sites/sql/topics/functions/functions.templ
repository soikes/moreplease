package functions_topic

import (
    "embed"
    "soikke.li/moreplease/sites/sql/db"
    st "soikke.li/moreplease/sites/sql/templates"
    "soikke.li/moreplease/templates"
)

//go:embed sql
var sqlFiles embed.FS

templ Topic() {
    {{
        s := db.Statements{
            Files: sqlFiles,
            SchemaPath: "sql/schema/schema.sql",
        }
        e := st.Example{
            Statements: s,
        }
    }}
    @templates.Base("More SQL Please: Functions") {
        <div class="content wide">
            @st.TopicTitle("Functions")
            @st.Schema(s, "users", "transactions")
            <div class="container">
                <div>
                    Most relational database engines support the ability to create and call functions as part of a SQL statement. Most also have commonly used utility functions already built-in.<br><br>
                    Functions that accept zero or more input values and produce a single output value per row are called "simple" or "scalar" functions. There are other types of functions that work with more than one row at a time and they are generally grouped into <a href="aggregate_functions">Aggregate Functions</a> and <a href="window_functions">Window Functions</a>.<br><br>
                    <span>@st.Inline("datetime()")</span> is a scalar function in SQLite that returns the current date and time.<br><br>
                    SQLite and most other database engines will publish <a href="https://www.sqlite.org/lang_corefunc.html">documentation<span>@st.Outlink()</span></a> on built-in functions available to use.
                </div>
                @e.Run("sql/functions_date.sql")
                <div>
                    Functions can operate on row results and be combined and nested as long as the data types of the inputs and outputs are all compatible.
                </div>
                @e.Run("sql/functions_nested.sql")
                <div>
                    Functions can be called in almost any part of a SQL query.
                </div>
                @e.Run("sql/statement_parts.sql")
                <div>
                    It is important to consider <span>@st.Inline("NULL")</span> input values in functions and understand how they are interpreted. For example the <span>@st.Inline("length()")</span> function in SQLite returns <span>@st.Inline("NULL")</span>, not 0.
                </div>
                @e.Run("sql/functions_null.sql")
                <div>
                    <span>@st.Inline("coalesce()")</span> is a commonly used function to handle <span>@st.Inline("NULL")</span> values by returning a "default" value if the input you supply evaluates to <span>@st.Inline("NULL")</span>.
                </div>
                @e.Run("sql/functions_coalesce.sql")
                <div>
                    Some functions are capable of accepting a variable amount of arguments. These are called <i>variadic functions</i>.<br><br>
                    A common example are string formatting functions like <span>@st.Inline("printf()")</span> (or <span>@st.Inline("format()")</span>). They often take in a "template" string that describes how you want the output string to be formatted, then any number of arguments that supply the data to fill it in with.<br><br>
                    In this case, <span>@st.Inline("%s")</span> means we want a string type to appear in that spot, and <span>@st.Inline("%.2f")</span> means we want a floating-point number rounded to two deicmal places to appear in that spot.<br><br>
                    A fun fact is that this is such a common problem to solve that most programming languages have <span>@st.Inline("printf()")</span> or some similar form of it.
                </div>
                @e.Run("sql/functions_variadic.sql")
                <div>
                    Some database engines support creating custom functions using the <span>@st.Inline("CREATE FUNCTION")</span>) statement. Others, like SQLite require you to define custom functions outside of the database and load them separately which we will not cover here.<br><br>
                    This example gives an idea of what a user-defined/custom function would typically look like in PostgreSQL, a different database engine, so ignore the syntax differences. This function could then be used anywhere a built-in function can be used by calling <span>@st.Inline("format_transaction(...)")</span>.
                </div>
                @e.Display("sql/functions_user_defined.sql")
            </div>
        </div>
    }
}
